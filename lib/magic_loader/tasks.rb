#--
# Copyright (C)2010 Tony Arcieri
# You can redistribute this under the terms of the MIT license
# See file LICENSE for details
#++

require 'magic_loader'
require 'rake/tasklib'

# Generates the MagicLoader rake task, which 
class MagicLoader::Task < Rake::TaskLib
  BEGIN_MAGIC = "#-----BEGIN MAGICLOADER MAGIC BLOCK-----"
  END_MAGIC   = "#------END MAGICLOADER MAGIC BLOCK------"
  MAGIC_WARNING = [
    "# Automagically generated by MagicLoader. Editing may",
    "# result in bad juju. Edit at your own risk!"
  ]
  
  def initialize(*paths)
    options = paths.last.is_a?(Hash) ? paths.pop : {}
    task_name = options[:name] || 'magicload'
    
    task task_name do
      load_order = MagicLoader.require_all(*paths)
      strip_paths!(load_order, options[:strip]) if options[:strip]

      magicload_block = [
        BEGIN_MAGIC,
        MAGIC_WARNING,
        "# Run \"rake #{task_name}\" to regenerate",
        load_order.map { |t| "require #{t.dump}" },
        END_MAGIC
      ].flatten.join("\n")
      
      if options[:target]
        if File.exists? options[:target]
          annotate_file options[:target], magicload_block
        else
          File.open(options[:target], "w") { |f| f << magicload_block }
        end
      else
        puts magicload_block
      end
    end
  end
  
  #######
  private
  #######
  
  # Implement the path stripping logic described in the README
  def strip_paths!(paths, to_strip)
    paths.map! do |path|
      case to_strip
      when String
        if path.index(to_strip) == 0
          path.sub to_strip, ''
        else
          path
        end
      when Regexp
        path.sub to_strip, ''
      else raise ArgumentError, ":strip given a #{to_strip.class}"
      end
    end
  end
end