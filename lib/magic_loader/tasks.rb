#--
# Copyright (C)2010 Tony Arcieri
# You can redistribute this under the terms of the MIT license
# See file LICENSE for details
#++

require 'magic_loader'
require 'rake/tasklib'

# Generates the MagicLoader rake task
module MagicLoader
  BEGIN_MAGIC = "#-----BEGIN MAGICLOADER MAGIC BLOCK-----"
  END_MAGIC   = "#------END MAGICLOADER MAGIC BLOCK------"
  MAGIC_WARNING = [
    "# Automagically generated by MagicLoader. Editing may",
    "# result in bad juju. Edit at your own risk!"
  ]
  MAGIC_REGEXP = /#{BEGIN_MAGIC}.*#{END_MAGIC}/m
  
  # Generates the MagicLoader rake task
  class Task < Rake::TaskLib
    # FIXME: Yeah all this functionality really shouldn't be part of the Rake
    # task. It should be all nicely factored into a reusable class with all
    # the core functionality exposed, then wrapped in a Rake task. But I'm
    # lazy and just trying to get this thing out the door, and Rake tasks
    # are my main use case. Got a problem? Refactor me!
    
    # Please see the README for how to use this task
    def initialize(*paths)
      options = paths.last.is_a?(Hash) ? paths.pop : {}
      task_name = options[:name] || 'magicload'
    
      desc "Automagically calculate code dependencies"
      task task_name do
        load_order = MagicLoader.require_all(*paths)
        strip_paths!(load_order, options[:strip]) if options[:strip]

        magic_block = [
          BEGIN_MAGIC,
          MAGIC_WARNING,
          "# Run \"rake #{task_name}\" to regenerate",
          load_order.map { |t| "require #{t.dump}" },
          END_MAGIC
        ].flatten.join("\n")
      
        if options[:target]
          if File.exists? options[:target]
            annotate_file options[:target], magic_block
          else
            File.open(options[:target], "w") { |f| f << magic_block }
          end
        else
          puts magic_block
        end
      end
      
      if options[:clean]
        namespace task_name do
          desc "Remove the previous MagicLoader block"
          task :clean do
            strip_magic_block options[:target]
          end
        end
        
        Rake::Task[task_name].prerequisites << "#{task_name}:clean"
      end
    end
  
    #######
    private
    #######
  
    # Implement the path stripping logic described in the README
    def strip_paths!(paths, to_strip)
      paths.map! do |path|
        case to_strip
        when String
          if path.index(to_strip) == 0
            path.sub to_strip, ''
          else
            path
          end
        when Regexp
          path.sub to_strip, ''
        else raise ArgumentError, ":strip given a #{to_strip.class}"
        end
      end
    end
  
    # Annotate a MagicLoader Magic Block onto the end of an existing file
    def annotate_file(path, magic_block)
      data = File.read path
      
      # Remove trailing whitespace from the file so it doesn't grow
      data.sub!(/\w+$/m, '')
      
      magic_matches = data.match(MAGIC_REGEXP)
      case magic_matches
      when MatchData
        data.sub!(MAGIC_REGEXP, magic_block)
      else
        data << "\n\n" << magic_block
      end
    
      File.open(path, 'w') { |f| f << data }
    end
    
    # Remove the MagicLoader block from a particular file
    def strip_magic_block(file)
      data = File.read path
      data.sub(MAGIC_REGEXP, '')
      File.open(path, 'w') { |f| f << data }
    end
  end
end